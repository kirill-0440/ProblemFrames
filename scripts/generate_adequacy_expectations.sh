#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "${SCRIPT_DIR}/.." && pwd)"

usage() {
  cat <<'USAGE'
Usage:
  bash ./scripts/generate_adequacy_expectations.sh [options]

Options:
  --selection <path>        Adequacy selection env file
                            (default: models/system/adequacy_selection.env)
  --output <path>           Output TSV path
                            (default: ADEQUACY_EXPECTATIONS from selection file)
  --command-pattern <glob>  Command glob to include as required rules
                            (default: Obl_*)
  --expected <SAT|UNSAT>    Expected verdict for required command rules
                            (default: UNSAT)
  --check                   Verify output file is up to date; do not rewrite
  -h, --help                Show this help
USAGE
}

selection_file="${REPO_ROOT}/models/system/adequacy_selection.env"
output_file=""
command_pattern=""
expected_verdict=""
check_mode=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --selection)
      selection_file="$2"
      shift 2
      ;;
    --output)
      output_file="$2"
      shift 2
      ;;
    --command-pattern)
      command_pattern="$2"
      shift 2
      ;;
    --expected)
      expected_verdict="$2"
      shift 2
      ;;
    --check)
      check_mode=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ "${selection_file}" != /* ]]; then
  selection_file="${REPO_ROOT}/${selection_file}"
fi
if [[ ! -f "${selection_file}" ]]; then
  echo "Selection file not found: ${selection_file}" >&2
  exit 1
fi

# shellcheck disable=SC1090
source "${selection_file}"

: "${PASS_FIXTURE:?missing PASS_FIXTURE in selection file}"
: "${FAIL_FIXTURE:?missing FAIL_FIXTURE in selection file}"

if [[ -z "${output_file}" ]]; then
  output_file="${ADEQUACY_EXPECTATIONS:-models/system/adequacy_expectations.tsv}"
fi
if [[ "${output_file}" != /* ]]; then
  output_file="${REPO_ROOT}/${output_file}"
fi

if [[ -z "${command_pattern}" ]]; then
  command_pattern="${ADEQUACY_COMMAND_PATTERN:-Obl_*}"
fi

if [[ -z "${expected_verdict}" ]]; then
  expected_verdict="${ADEQUACY_EXPECTED_VERDICT:-UNSAT}"
fi
expected_verdict="${expected_verdict^^}"
if [[ "${expected_verdict}" != "SAT" && "${expected_verdict}" != "UNSAT" ]]; then
  echo "Invalid expected verdict: ${expected_verdict} (must be SAT or UNSAT)" >&2
  exit 1
fi

pass_fixture_path="${REPO_ROOT}/${PASS_FIXTURE}"
fail_fixture_path="${REPO_ROOT}/${FAIL_FIXTURE}"

if [[ ! -f "${pass_fixture_path}" ]]; then
  echo "Pass fixture not found: ${pass_fixture_path}" >&2
  exit 1
fi
if [[ ! -f "${fail_fixture_path}" ]]; then
  echo "Fail fixture not found: ${fail_fixture_path}" >&2
  exit 1
fi

tmp_output="$(mktemp)"
tmp_als="$(mktemp)"
tmp_commands="$(mktemp)"
trap 'rm -f "${tmp_output}" "${tmp_als}" "${tmp_commands}"' EXIT

collect_fixture_rules() {
  local fixture_path="$1"
  local fixture_rel="$2"
  local class_id="$3"
  local has_rows=0

  cargo run -q -p pf_dsl -- "${fixture_path}" --alloy > "${tmp_als}"

  awk '/^[[:space:]]*run[[:space:]]+/ {print $2}' "${tmp_als}" \
    | awk '!seen[$0]++' > "${tmp_commands}"

  while IFS= read -r command_name; do
    if [[ -z "${command_name}" ]]; then
      continue
    fi
    if [[ "${command_name}" != ${command_pattern} ]]; then
      continue
    fi
    has_rows=1
    printf '%s|%s|%s|Autogenerated from %s (%s)|required\n' \
      "${fixture_rel}" \
      "${command_name}" \
      "${expected_verdict}" \
      "${fixture_rel}" \
      "${class_id}" >> "${tmp_output}"
  done < "${tmp_commands}"

  if [[ "${has_rows}" -eq 0 ]]; then
    echo "No commands matched pattern '${command_pattern}' in ${fixture_rel}" >&2
    exit 1
  fi
}

class_id="${ADEQUACY_CLASS_ID:-adequacy_class}"

{
  echo "# model_pattern|command_pattern|expected|note|required"
  echo "# Auto-generated by scripts/generate_adequacy_expectations.sh."
  echo "# First matching rule wins. Keep specific rules above wildcard defaults."
  echo
} > "${tmp_output}"

collect_fixture_rules "${pass_fixture_path}" "${PASS_FIXTURE}" "${class_id}"
collect_fixture_rules "${fail_fixture_path}" "${FAIL_FIXTURE}" "${class_id}"

if [[ "${ADEQUACY_INCLUDE_DEFAULT_FALLBACK:-1}" == "1" ]]; then
  fallback_verdict="${ADEQUACY_FALLBACK_VERDICT:-SAT}"
  fallback_verdict="${fallback_verdict^^}"
  if [[ "${fallback_verdict}" != "SAT" && "${fallback_verdict}" != "UNSAT" ]]; then
    echo "Invalid ADEQUACY_FALLBACK_VERDICT: ${fallback_verdict}" >&2
    exit 1
  fi
  {
    echo
    printf '*|*|%s|Default fallback for commands outside the selected adequacy fixture contract|optional\n' "${fallback_verdict}"
  } >> "${tmp_output}"
fi

mkdir -p "$(dirname -- "${output_file}")"

if [[ "${check_mode}" -eq 1 ]]; then
  if [[ ! -f "${output_file}" ]]; then
    echo "Adequacy expectations file is missing: ${output_file}" >&2
    exit 1
  fi
  if ! diff -u "${output_file}" "${tmp_output}" >/dev/null; then
    echo "Adequacy expectations file is out of date: ${output_file}" >&2
    diff -u "${output_file}" "${tmp_output}" || true
    exit 1
  fi
  echo "Adequacy expectations are up to date: ${output_file}"
  exit 0
fi

cp "${tmp_output}" "${output_file}"
echo "Generated ${output_file}"
