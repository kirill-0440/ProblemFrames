use crate::ast::*;
use anyhow::Result;
use std::fmt::Write;

pub fn generate_rust(problem: &Problem) -> Result<String> {
    let mut code = String::new();

    writeln!(code, "// Generated by PF DSL for Problem: {}", problem.name)?;
    writeln!(code, "#[allow(dead_code)]")?;
    writeln!(code, "")?;

    // 1. Generate Enums for Interfaces
    for interface in &problem.interfaces {
        let enum_name = sanitize_name(&interface.name) + "Phenomena";
        writeln!(code, "/// Interface: {}", interface.name)?;
        writeln!(code, "#[derive(Debug, Clone, PartialEq)]")?;
        writeln!(code, "pub enum {} {{", enum_name)?;
        
        for p in &interface.shared_phenomena {
            // e.g. Open(String) or just Open
            // For now, unit variants for Events, maybe wrap value for Value?
            match p.type_ {
                PhenomenonType::Value => {
                    writeln!(code, "    {}(String), // Value from {} -> {}", sanitize_name(&p.name), p.from, p.to)?;
                }
                _ => {
                    writeln!(code, "    {}, // {:?} from {} -> {}", sanitize_name(&p.name), p.type_, p.from, p.to)?;
                }
            }
        }
        writeln!(code, "}}")?;
        writeln!(code, "")?;
    }

    // 2. Generate Structs for Domains
    for domain in &problem.domains {
        writeln!(code, "/// Domain: {} [{:?}]", domain.name, domain.domain_type)?;
        writeln!(code, "#[derive(Debug)]")?;
        writeln!(code, "pub struct {} {{", sanitize_name(&domain.name))?;
        writeln!(code, "    // TODO: Add internal state")?;
        writeln!(code, "}}")?;
        writeln!(code, "")?;
        
        // Generate impl stub
        writeln!(code, "impl {} {{", sanitize_name(&domain.name))?;
        writeln!(code, "    pub fn new() -> Self {{")?;
        writeln!(code, "        Self {{}}")?;
        writeln!(code, "    }}")?;
        writeln!(code, "}}")?;
        writeln!(code, "")?;
    }

    Ok(code)
}

fn sanitize_name(name: &str) -> String {
    // Replace non-alphanumeric with nothing or _, ensure starts with Capital
    // Simple version:
    let mut s = name.replace(|c: char| !c.is_alphanumeric(), "");
    // Ensure first char is uppercase
    if let Some(c) = s.chars().next() {
        if c.is_lowercase() {
            s.replace_range(0..1, &c.to_uppercase().to_string());
        }
    }
    s
}
