problem: PF_DSL_Tool

// 1. Domains
domain Developer kind biddable role given // The user of the tool
domain SourceFile kind lexical role given // The .pf file on disk
domain Tool kind causal role machine      // The CLI/LSP tool
domain Editor kind causal role given      // VS Code or other editor (interacting with LSP)
domain GeneratedCode kind lexical role given // The Rust code or DOT output

// 2. Interfaces

// Developer edits the SourceFile
interface "Dev-Source" connects Developer, SourceFile {
    shared: {
        phenomenon Edit : event [Developer -> SourceFile] controlledBy Developer
    }
}

// Developer invokes tool actions
interface "Dev-Tool" connects Developer, Tool {
    shared: {
        phenomenon RunValidation : command [Developer -> Tool] controlledBy Developer
    }
}

// Tool reads the SourceFile
interface "Tool-Source" connects Tool, SourceFile {
    shared: {
        phenomenon FileContent : value [SourceFile -> Tool] controlledBy SourceFile
        phenomenon FileExists : state [SourceFile -> Tool] controlledBy SourceFile
    }
}

// Tool interacts with Editor via LSP
interface "Tool-Editor" connects Tool, Editor {
    shared: {
        phenomenon DidOpen : event [Editor -> Tool] controlledBy Editor
        phenomenon DidChange : event [Editor -> Tool] controlledBy Editor
        phenomenon PublishDiagnostics : event [Tool -> Editor] controlledBy Tool
        phenomenon Hover : event [Editor -> Tool] controlledBy Editor
        phenomenon HoverInfo : value [Tool -> Editor] controlledBy Tool
    }
}

// Tool generates output (Code or DOT)
interface "Tool-Output" connects Tool, GeneratedCode {
    shared: {
        phenomenon WriteFile : event [Tool -> GeneratedCode] controlledBy Tool
        phenomenon CodeStructure : value [Tool -> GeneratedCode] controlledBy Tool
    }
}

// Developer views the Output/Editor
interface "Dev-View" connects Developer, Editor, GeneratedCode {
    shared: {
        phenomenon SeeSquiggles : event [Editor -> Developer] controlledBy Editor
        phenomenon ReadCode : value [GeneratedCode -> Developer] controlledBy GeneratedCode
    }
}

// 3. Requirements

// Requirement 1: Feedback on Validity
// Frame: RequiredBehavior
requirement "ImmediateFeedback" {
    frame: RequiredBehavior
    constraint: "Developer sees errors immediately"
    constrains: Editor
}

// Requirement 2: Correct Code Generation
// Frame: CommandedBehavior
requirement "ScaffoldGeneration" {
    frame: CommandedBehavior
    constraint: "Generated code matches domain definitions"
    constrains: GeneratedCode
    reference: Developer
}

worldProperties W_tooling {
    assert "SourceFile content can be read after each Edit event" @LTL
}

specification S_tooling {
    assert "RunValidation eventually triggers PublishDiagnostics for open files" @LTL
}

requirementAssertions R_feedback {
    assert "Developer sees validation feedback without leaving the editor flow" @LTL
}

correctnessArgument A_feedback_loop {
    prove S_tooling and W_tooling entail R_feedback
}
